package generator

const (
	tmplHeader = `{{- define "tmplHeader"}}
// Code generated by cool go-validate tool; DO NOT EDIT.
package {{.PackageName}}

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

var (
	ErrFieldLen   = errors.New("validate: field does not match length")
	ErrFieldRegex = errors.New("validate: field does not match regex")
	ErrFieldIn    = errors.New("validate: field does not exists in variety")
	ErrFieldMin   = errors.New("validate: field is less than min value")
	ErrFieldMax   = errors.New("validate: field is greater than max value")

	ErrWrongType  = errors.New("wrong type of field")
)

type ValidationError struct {
	fieldName string
	err       error
}

func validateLen(
	fieldName string,
	fieldValue interface{},
	tagValue string) (*ValidationError, error) {

	v, ok := fieldValue.(string)
	if !ok {
		return nil, ErrWrongType
	}

	i, err := strconv.Atoi(tagValue)
	if err != nil {
		return nil, err
	}

	if len(v) != i {
		return &ValidationError{
			fieldName: fieldName,
			err:       ErrFieldLen,
		}, nil
	}
	return nil, nil
}

func validateRegex(
	fieldName string,
	fieldValue interface{},
	tagValue string) (*ValidationError, error) {

	v, ok := fieldValue.(string)
	if !ok {
		return nil, ErrWrongType
	}

	r := regexp.MustCompile(tagValue)

	if !r.MatchString(v) {
		return &ValidationError{
			fieldName: fieldName,
			err:       ErrFieldRegex,
		}, nil
	}
	return nil, nil
}

func validateInString(
	fieldName string,
	fieldValue interface{},
	tagValue string) (*ValidationError, error) {

	v, ok := fieldValue.(string)
	if !ok {
		return nil, ErrWrongType
	}

	var in bool

	for _, s := range strings.Split(tagValue, ",") {
		if v == s {
			in = true
			break
		}
	}

	if !in {
		return &ValidationError{
			fieldName: fieldName,
			err:       ErrFieldIn,
		}, nil
	}
	return nil, nil
}

func validateInInt(
	fieldName string,
	fieldValue interface{},
	tagValue string) (*ValidationError, error) {

	v, ok := fieldValue.(int)
	if !ok {
		return nil, ErrWrongType
	}

	var in bool

	for _, s := range strings.Split(tagValue, ",") {
		i, err := strconv.Atoi(s)
		if err != nil {
			return nil, err
		}
		if v == i {
			in = true
			break
		}
	}

	if !in {
		return &ValidationError{
			fieldName: fieldName,
			err:       ErrFieldIn,
		}, nil
	}

	return nil, nil
}

func validateMin(
	fieldName string,
	fieldValue interface{},
	tagValue string) (*ValidationError, error) {

	v, ok := fieldValue.(int)
	if !ok {
		return nil, ErrWrongType
	}

	i, err := strconv.Atoi(tagValue)
	if err != nil {
		return nil, err
	}

	if v < i {
		return &ValidationError{
			fieldName: fieldName,
			err:       ErrFieldMin,
		}, nil
	}

	return nil, nil
}

func validateMax(
	fieldName string,
	fieldValue interface{},
	tagValue string) (*ValidationError, error) {

	v, ok := fieldValue.(int)
	if !ok {
		return nil, ErrWrongType
	}

	i, err := strconv.Atoi(tagValue)
	if err != nil {
		return nil, err
	}

	if v > i {
		return &ValidationError{
			fieldName: fieldName,
			err:       ErrFieldMax,
		}, nil
	}

	return nil, nil
}

{{end}}`
)
